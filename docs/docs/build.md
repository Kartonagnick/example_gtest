[![logo](../logo.png)](../docs.md "documentation") 

[H]: ../docs.md        "родитель"
[P]: ../icons/progress.png  "в процессе..."
[S]: ../icons/success.png   "ошибок не обнаружено"
   
[![P]][H] build v0.0.1
======================
Каталоги, где происходит сборка и размещение результатов,  
располагаются на уровень выше по отношению к репозиторию проекта.  

```
repo
 |--- _build         сборочные проекты
 |--- _external      результаты сборки внешних библиотек
 |--- _product       результаты сборки нашего проекта
 |--- _repo          скачанные репозитории
  `-- example_gtest  наш репозиторий
```

Общие особенности сборки
---
В рамках данного проекта gtest собирается "как есть".  
Однако нужно иметь ввиду, что по-хорошему, нужно собирать gtest с теми же ключами компилятора,  
с которыми собирается основной проект.  
Несовпадение по ключам может привести к ошибкам сборки,  
или, что ещё хуже, к сложно диагностируемым ошибкам ODR  

> Конкретно, в случае с `gtest`, несовпадение параметра `CMAKE_CXX_STANDARD`  
> приводило к ошибкам сборки `msvc2015`  

В общем случае множество конфигураций можно охарактеризовать:  
  - static/dynamic : линковка с райтайм-библиотеками с++  
  - debug/release  : отладочная или релизная сборка  
  - 32/64          : битность сборки  

Важно, что бы скрипты сборки учитывали эти критичные параметры.  
И что бы итоговые результаты сборки раскладывались по разным каталогам,
и не перепутывались между собой.

В рамках данного проекта, артефакты сборки располагаются по принципу: `libname-compiler-bit-crt`  
Например:  

```
repo
 |--- _external
       |--- gtest-mingw810-32-md
       |     |--- include
       |      `-- lib
       |           |--- libgmock.a
       |            `-- libgmock_d.a
       |--- gtest-msvc2022-64-mt
       |     |--- include
              `-- lib
                   |--- gmock.lib
                    `-- gmock_d.lib
```
<br/>


Обратите внимание: отладочные и релизные библиотеки лежат в одном каталоге,  
Но у отладочных библиотек добавляется постфикс `_d`  
Это - стандартная практика для хранение библиотек.  

В данной схеме не хватает очень важной детали: версии библиотеки.  
По-хорошему, версию  тоже нужно учитывать.  
В реальности многие проекты зависят от конкретных версий, и абы какая им не подойдет.  
Однако в рамках данного проекта параметр `версия` не используется.  
Это сделано специально, что бы упросить сборочные скрипты.  
<br/>


Сборка Visual Studio 2022  
---
Особенность студийных проектов заключается в том,  
что у них по умолчанию есть деление на `debug` и `release`  
Другая особенность: принципиальное значение имеют ключи `/MT` `/MD`  
Если ключи не совпадут, библиотека и приложение не смогут слинковаться.  
  - `/MT`  : static  линковка с рантайм-библиотеками с++ для релизной сборки  
  - `/MTd` : static  линковка с рантайм-библиотеками с++ для отладочной сборки  
  - `/MD`  : dynamic линковка с рантайм-библиотеками с++ для релизной сборки  
  - `/MDd` : dynamic линковка с рантайм-библиотеками с++ для отладочной сборки  

Так же, принципиальное значение имеет 32 или 64 битная сборка.  
Битность указывается ещё при запуске cmake, на этапе генерации проекта.  
Для этого используются дополнительные опции: `-A Win32` или `-A x64`  

Пример генерации 64х битного проекта:  

```bat
cmake                        ^
  -S"%eDIR_SOURCE%"          ^
  -B"%eDIR_BUILD%"           ^
  -G"Visual Studio 17 2022"  ^
  -A x64
```

Пример генерации 32х битного проекта:  

```bat
cmake                        ^
  -S"%eDIR_SOURCE%"          ^
  -B"%eDIR_BUILD%"           ^
  -G"Visual Studio 17 2022"  ^
  -A Win32
```

Что касается ключей `/MT` или `/MD`, в каждом конкретном случае их передают по разному.  
Это уже на усмотрение разработчика сценария сборки cmake.  
Например, в сценарии сборки gtest за это отвечает параметр `-D"gtest_force_shared_crt=ON"`  
Если параметр определен, значит нужно использовать `/MD`, а иначе `/MT`  
Пример генерации 64х битного проекта с ключем `/MD`:  
```bat
cmake                           ^
  -S"%eDIR_SOURCE%"             ^
  -B"%eDIR_BUILD%"              ^
  -G"Visual Studio 17 2022"     ^
  -D"gtest_force_shared_crt=ON" ^
  -D"CMAKE_DEBUG_POSTFIX=_d"    ^
  -A x64
```
Ещё одна немаловажная особенность студийной сборки: по умолчанию, gtest падает в каталоги  
  - `C:\Program Files (x86)\googletest-distribution`  
  - `C:\Program Files\googletest-distribution`  

И вот тут возникают сразу две проблемы:  
Во-первых, нет деления на MT/MD, что в дальнейшем может создать проблемы.  
А во-вторых, стандартный способ подключения библиотеки к проекту:  

```
# --- tests/CMakeLists.txt
find_package(GTest REQUIRED)
```
Завершается ошибкой: `find_package` не сможет найти gtest по дефолтным путям.  
Для успешной линковки, нужно обязательно сообщить cmake, где искать gtest  
Для этого нужно задать переменную окружения `GTEST_DIR`  

Пример генерации проекта, который хочет линковаться с gtest  
```bat
  set "GTEST_DIR=C:\Program Files\googletest-distribution"
  cmake                         ^
    -S"%eDIR_SOURCE%"           ^
    -B"%eDIR_BUILD%"            ^
    -G"Visual Studio 17 2022"   ^
    -D"CMAKE_DEBUG_POSTFIX=_d"  ^
    -A x64
```
Обратите внимание на ключик `-D"CMAKE_DEBUG_POSTFIX=_d"`  
Он должен совпадать с аналогичным при сборке gtest.  
Иначе find_package не сможет правильно различить релизные и дебажные библиотеки.  

В такой ситуации теряется смысл установки gtest по дефолтным путям.  
Ведь в любом случае нужно будет указывать путь для поиска.  
Поэтому, лучше установить готовые библиотеки в специальные каталоги так,  
что бы можно было различать сборки с разными ключами `/MD` и `/MT`

Каталог `example_gtest/deploy/msvc` содержит готовые сборочные скрипты,  
которые заранее учитывают нюансы, и устроенны таким образом,  
что бы было легко добавить сборку очередной студии.  

Пример сборки компилятором Visual Studio:  

```bat
rem заходим в каталог развертывания
cd ./example_gtest/deploy/msvc

rem запускаем сборку gtest
./build_gtest.bat

rem запускаем сборку проекта
./build_project.bat
```

По умолчанию батники настроенны на сборку msvc2022.  
Если нужно собирать какой то другой студией,  
тогда откройте батники на редактирование,  
и по аналогии с msvc2022, впишите данные для другой студии.  
<br/>


Сборка mingw
---
Особенность сборки mingw заключается в том,  
что на локальной может быть установленно множество компиляторов,  
и что бы подключить компилятор нужной версии,  
нужно прописать путь к его бинарнику в переменной окружения PATH  

А в рамках данного проекта пути к компиляторам mingw указываются в файле:  
```bat
example_gtest/deploy/mingw/path.bat
```
Нужно просто открыть файл на редактирование, и по аналогии с имеющимися образцами,  
прописать пути к своим компиляторам.  

Далее, просто запускаем сборочные скрипты:  

```bat
rem заходим в каталог развертывания
cd ./example_gtest/deploy/mingw

rem запускаем сборку gtest
./build_gtest.bat

rem запускаем сборку проекта
./build_project.bat
```

По умолчанию батники собирают для mingw810  
Если у вас другая версия mingw, тогда можно открыть батники на редактирование,  
и по аналогии с 810, прописать нужные компиляторы.  

Другая особенность сборки mingw заключается в том,  
что конкретно сборка gtest не учитывает `MT/MD`  

В обоих случаях плучается бинарник одинакового размера.  
Однако ключи `MT/MD` влияют на бинарник итогового приложения.  
Сборка с ключем `/MD` требует наличия mingw-runtime c++  
  - libgcc_s_dw2-1.dll  
  - libstdc++-6.dll  
<br/>


Сборка gcc
---
Особенность сборки gcc заключается в том,  
что обычно в системе Linux из коробки доступен некоторый относительно новый компилятор.  
И именно этим компилятором запускается сборка.  
При этом, результаты сборки по умолчанию устанавливаются в правильные каталоги системы,  
и далее, их без проблем находят функции cmake, такие как find_package  

```
# --- tests/CMakeLists.txt
find_package(GTest REQUIRED)
```

Другой особенностью сборки под linux, именно касательно сборки gtest,  
заключается в том, что для gcc она не учитывает `MT/MD`  
При этом, поскольку в системе присутствует gcc, и полюбому доступен необходимый рантайм,  
то нет никаких проблем с запуском сборок с динамическим рантаймом.  

Пример сборки компилятором gcc:  

```bash
# заходим в каталог развертывания
cd ./example_gtest/deploy/gcc

# запускаем сборку gtest
./build_gtest.bat

# запускаем сборку проекта
./build_project.bat
```

История изменений 
-----------------

|  ID  |    дата    | время |     ветка      | status  |      длительность     |
|:----:|:----------:|:-----:|:--------------:|:-------:|:---------------------:|
| 0001 | 2025-12-03 | 19:10 | [#2-dev-frame] | VERSION | 1 день 6 часов 40 мин |

[#2-dev-frame]: ../history.md#-v002-dev
