[![logo](../logo.png)](../docs.md "documentation") 

[H]: ../docs.md        "родитель"
[P]: ../icons/progress.png  "в процессе..."
[S]: ../icons/success.png   "ошибок не обнаружено"

[1]: ../../tests/mock/test-mock1.cpp
[2]: ../../tests/mock/test-mock3.cpp
[3]: ../../tests/mock/test-const-ref.cpp
[4]: ../../tests/mock/test-const-ptr.cpp



[5]: ../../tests/mock/test-matcher.cpp
[6]: ../../tests/mock/test-array.cpp
[7]: ../../tests/turtle/test-turtle-general.cpp
[8]: ../../tests/turtle/test-turtle-sequences.cpp
[9]: ../../tests/turtle/test-turtle-sticky.cpp

   
[![S]][H] mock v0.0.1
=====================
Каталог примеров использования:  
  - [WillOnce][1] настройка для однократного вызова  
  - [SetArgReferee][1] позволяет установить значение dst-параметра  
  - [SetArgPointee][1] позволяет установить значение dst-параметра  
  - [array/container][6] работа с массивами/контейнерами  
  - [Times(количество)][1] устанавливает ожидаемое кол-во вызовов  
  - [NiceMock][2] 1 пример использования милого мок-объекта (подавление предупреждений)  
  - [NiceMock][7] 2 пример использования милого мок-объекта (подавление предупреждений)  
  - [lambda][2] пример использования вызова произвольной лямбды  
  - [Invoke][2] пример использования вызова произвольного метода  
  - [InvokeWithoutArgs][2] вызов произвольного метода  
  - [const mock][3] запуск от имени константного мок-объекта  
  - [ReturnRef][3] возвращение ссылки из метода мок-объекта  
  - [ReturnPointee][4] возвращение данных по указателю из метода мок-объекта  
  - [Matcher][5] пример использования различных Matchers  
  - [WillByDefault][7] Поведение по умолчанию  
  - [Sequence][8] задание очередности вызовов  
  - [InSequence][8] задание очередности вызовов  
  - [RetiresOnSaturation][9] решение проблемы Sticky  

<br/>

Немножко философии: допустим, есть объект бизнес-логики Order,  
который для своей работы использует подключение к базе данных.  

Предположим, что это какая то тяжелая база данных,  
разворот которой сопряжен с значительными трудностями.  

И тогда возникает вопрос: можно ли как то протестировать Order  
без необходимости разворачивать боевое окружение?  

Существует множество подходов, которые позволяют провернуть подобное.  
И самое первое, что приходит в голову: использование интерфейсов,  
с помощью которых можно подменить боевую реализацию на тестовую.  

Пример использования фейкового объекта:  

```cpp
struct IDatabase
{
    virtual ~IDatabase() {}
    virtual int query(int) = 0;
};

struct Order
{
    Order(IDatabase& db_): db(&db_) }
    int check(int id) { return db->query(id); }
    IDatabase* db;
};
    
struct FakeDatabase: IDatabase
{
    int query(int) { return 0; }
};

TEST(Order, 001)
{
    FakeDatabase db; 
    Order order(db); 
    ASSERT_EQ(order.check(100), 0); 
}
```

Плюсы такого подхода в относительной простоте идеи:  
мы просто переопределяем нужные виртуальные функции-члены.  

Но есть и минусы: фейковые классы приходится каждый раз писать с нуля.  
Причем, для описания разного поведения нужно реализовывать разные классы-имплементации.  
Иногда это может приводить к чрезмерному усложнению тестового кода.  
А кроме того, не существует единого стандарта написания фейковых классов.  
Поэтому фейковые классы от разных программистов могут сильно различаться.  
Соответственно, что бы понять чужой код юнит-теста,  
нужно вникать в детали реализаций фейковых классов.  


Альтернативный подход заключается в том, что бы использовать мок-объекты.  
Мок-объект - это объект, поведение которого программируется по особым правилам.  
Важная особенность: программируется поведение именно объекта, а не класса.  
Т.е., на базе одного и того же мок-класса, можно создавать множество мок-объектов,  
которые можно запрограммировать на выполнение разных действий.  
Причем, способ программирования поведения мок-объекта максимально наглядный.  
Поведение описывается прямо по месту, поэтому не нужно никуда далеко лазить,  
что бы понять, как поведет себя мок-объект в каждом конкретном случае.  

Например:

```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>

struct IDatabase
{
    virtual ~IDatabase() {}
    virtual int query(int) = 0;
};

struct Order
{
    Order(IDatabase& db_): db(&db_) {}
    int check(int id) { return db->query(id); }
    IDatabase* db;
};

struct MockDatabase: IDatabase
{
    // описывается только прототип без реализации
    MOCK_METHOD(int, query, (int), (override));
};

using ::testing::_;       // означает, что аргумент может быть любым
using ::testing::Return;  // позволяет указать что метод должен вернуть

TEST(Order, 002)
{
    v1::MockDatabase db; 

    // программа действий:
    // мок-объект ожидает, что будет выполнен однократный вызов 
    // db.query( аргумент не важен )
    // при этом метод вернет ноль
    
    EXPECT_CALL(db, query(_))
        .WillOnce(Return(0));

    v1::Order order(db); 
    
    // вызов order.check приведет к запуску db.query(100)
    // и, в соответствии с заданной программой,
    // мок-объект вернет ноль
    ASSERT_EQ(order.check(100), 0); 
}
```

Гугл-мок - довольно таки развитая система.  
Позволяет гибко задавать ожидаемое поведение мок-объектов,  
и контролируровать, что мок-объекты вызываются с правильными аргументами,  
правильное количество раз, в правильной последовательности.  

Единственный недостаток: нужно выучить и запомнить набор методов,  
при помощи которых программируются мок-объекты.  
Однако хорошая новость в том, что их не так уж много,  
поэтому материал усваивается быстро.  
<br/>


История изменений 
-----------------

|  ID  |    дата    | время |      ветка      | status  |  длительность  |
|:----:|:----------:|:-----:|:---------------:|:-------:|:--------------:|
| 0001 | 2025-12-05 | 22:20 | [#3-dev-sample] | VERSION | 22 часа 50 мин |

[#3-dev-sample]: ../history.md#-v003-dev
